<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=stylesheet href=https://hsd-dev.org/css/main.css><link rel=stylesheet href=https://hsd-dev.org/css/github-markdown.min.css><link rel=stylesheet href=/HIPs/css/style.css><title>Escher Update Chains for decentralized subdomains - Handshake Improvement Proposals</title><link rel=icon type=image/x-icon href=https://handshake.org/img/favicon/hns-favicon.ico><title>Handshake Improvement Proposals</title><meta name=title content="Escher Update Chains for decentralized subdomains"><meta name=description content="HIP-0016 - Category: Standards - Status: Draft"><meta name=author content="Matthew Zipkin <@pinheadmz>"><meta property="og:type" content="website"><meta property="og:url" content="https://hsd-dev.org/HIPs/proposals/0016/"><meta property="og:title" content="Escher Update Chains for decentralized subdomains"><meta property="og:description" content="HIP-0016 - Category: Standards - Status: Draft"><meta property="og:image" content="https://hsd-dev.org/img/logo.svg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://hsd-dev.org/HIPs/proposals/0016/"><meta property="twitter:title" content="Escher Update Chains for decentralized subdomains"><meta property="twitter:description" content="HIP-0016 - Category: Standards - Status: Draft"><meta property="twitter:image" content="https://hsd-dev.org/img/logo.svg"></head><body><header><a href=/><img alt="Handshake logo" src=https://hsd-dev.org/img/logo.svg></a></header><main><nav><div class=wrapper><ul><li><strong>HIPs</strong></li><li><a href=/>Home</a></li><li><a href=/HIPs/proposals/>Proposals</a></li><li><a href=https://t.me/hns_tech>Tech Chat</a></li></ul><ul><li><strong class=upper>category</strong></li><li class=capitalize><a href=https://hsd-dev.org/HIPs/category/informational>Informational</a></li><li class=capitalize><a href=https://hsd-dev.org/HIPs/category/standards>Standards</a></li><li class=capitalize><a href=https://hsd-dev.org/HIPs/category/standards-track>Standards track</a></li></ul><ul><li><strong class=upper>status</strong></li><li class=capitalize><a href=https://hsd-dev.org/HIPs/status/draft>Draft</a></li><li class=capitalize><a href=https://hsd-dev.org/HIPs/status/final>Final</a></li></ul></div></nav><article class=page><section class=markdown-body><h2>HIP-0016: Escher Update Chains for decentralized subdomains</h2><p><img src=hip-0016/DrawingHands.jpg alt="Drawing Hands"></p><h2 id=abstract>Abstract</h2><p>This document specifies a new protocol that enables a Handshake TLD to sell
subdomains in an unrevocable manner, eliminating the &ldquo;parent domain risk&rdquo;
inherent in domains below the blockchain-secured HNS root zone. The protocol
does not require any significant changes to the HNS blockchain consensus system.
However, a modest soft-fork will significantly improve the performance, security,
and accessibility of the system by light clients.</p><p>Escher deploys a new Urkel Tree for each TLD that opts-in to the protocol. In
this document we will refer to these as &ldquo;Escher Trees&rdquo; but they are just Urkel
trees with specific parameters. The roots of these Escher Trees are committed
to the HNS root zone Urkel Tree and are therefore verifiable by light clients.</p><p>Escher Trees are updated by inserting special transaction messages in the <code>data</code>
field of standard <code>UPDATE</code> covenants. These messages include proofs that can be
verified against the Escher Tree root currently committed in the TLD namestate.</p><p>A soft fork will require miners to enforce validity of these proofs, <strong>without
the miners needing to store the complete Escher Tree</strong>. Escher uses the Urkel
structure like an accumulator and is similar to <a href=https://dci.mit.edu/utreexo>utreexo</a>.</p><h2 id=motivation>Motivation</h2><p>Handshake offers users censorship-resistant, proof-of-work-secured top-level-domains
in an alternate root zone generated by the HNS blockchain. Since it&rsquo;s mainnet launch
the community has been desperate to develop a mechanism that can extend the same
minimal trust and security to subdomains of these TLDs, including bridging HNS
domains to external consensus systems <a href=https://registry.impervious.com/>like Ethereum</a>.</p><p>Escher is a decentralized subdomain proposal designed with these goals in mind:</p><ul><li>SLDs can not be revoked, transferred or updated by the TLD owner</li><li>Scalable (millions of TLDs with thousands or millions of subdomains)</li><li>Verifiable by light clients like the HNS root zone itself</li><li>HNS is the currency required for SLD purchase</li><li>No other consensus system or other blockchain is required</li><li>Minimal impact on HNS full nodes and miners</li></ul><p>In addition, Escher offers a number of other potential features which may or not be implemented:</p><ul><li>TLD owner receives payment when SLDs are transferred (sold by original owner)</li><li>SLDs are owned forever and never expire or require renewal</li></ul><h2 id=limitations>Limitations</h2><p>The most oppressive limit of Escher Update Chains is the 512 byte limit for
<code>UPDATE</code> covenant data (i.e. namestate data written to the Urkel Tree). This
limits the maximum Urkel proof size in the Escher messages and therefore limits
the maximum possible size of the Escher Tree itself.</p><p>This is an area of active research. <strong>The parameters currently specified by this
proposal will restrict the Escher tree to a maximum of around 4,000 dSLDs.</strong>
Once this limit is reached, the Escher tree will effectively freeze, since ANY
proofs required to update it will be too large to fit in an <code>UPDATE</code> covenant.
Because Urkel trees are sparse and proofs are optimized for space using collision
prefix bits, the exact maximum size of a proof depends on random bit collisions
between namehashes in the tree itself.</p><p>The 512-byte limit can be worked-around by at least these two methods:</p><ul><li>Deploy a hard fork that increases the maximum size for <code>UPDATE</code> covenant data.</li><li>Use witness data for the Urkel proofs, and use covenant data for tree roots only<ul><li>That gives us an extra 8,000 bytes but requires a new address type and witness version.</li><li>Increases code complexity quite a bit, since the UTXO script / witness system
is entirely separate from the covenant system.</li><li>However, this does make sense in that Escher Urkel proofs are essentially witness
data and can be pruned, that data does not need to live in the UTXO set.</li></ul></li></ul><h2 id=mechanism>Mechanism</h2><p>What we need is a way to efficiently prove to a light client what the valid
DNS records are for an SLD. We accomplish that in the same way we prove root
zone records to a light client: Urkel proofs.</p><p><strong>Escher dSLD data is limited to a single public key only, essentially a <code>DS</code>
record.</strong> This key is anchored to the Escher tree, which is anchored to the HNS root
Urkel tree:</p><pre tabindex=0><code>┌──────────────────────┐
│   HNS block header   │
│  ┌────────────────┐  │
│  │    treeRoot    │  │
│  └───────╱╲───────┘  │
└─────────╱──╲─────────┘
         ╱    ╲
        ▼      ▼
      hash   (node)
               ╱╲
              ╱  ╲
             ╱    ╲
            ▼      ▼
          hash  TLD data─────┐
                │ Escher root│   △ HNS full node △
                └─────╱╲─────┘  ===================
                     ╱  ╲         ▽ Escher data ▽
                    ╱    ╲
                   ▼      ▼
                (node)  hash
                  ╱╲
                 ╱  ╲
                ╱    ╲
               ▼      ▼
             hash  SLD data─────┐
                   │ public key │
                   └────────────┘
</code></pre><p>What we don&rsquo;t want to do is expect all full nodes to store Escher Trees for
millions and millions of TLDs, that will not scale. Fortunately, Urkel Trees
can be used like a utreexo &ldquo;accumulator&rdquo;. This means users can prove (to miners
and verifiers) that they are indeed updating the Escher Trees correctly according
to the dSLD rules <strong>without those verifiers needing complete copies of every tree.</strong></p><p>Complete trees can always be reassembled from historical blockchain data by
anyone. Entities that need to create Escher proofs will need those complete trees
to do so. These entities include dSLD buyers and dSLD name servers (provers). A
TLD owner would probably be incentivized to host this data in order to more
efficiently sell SLDs, and serve their customers better.</p><p>What we can do in 512 bytes is provide compressed Escher Tree operations, that
include at least:</p><ul><li>A proof of the current state of a <code>key:value</code> pair</li><li>The new <code>key:value</code> pair</li><li>The NEW root hash that commits the updated Escher Tree</li></ul><p>This is all the data needed for verifiers to enforce rules, and for light clients
to verify dSLD proofs. This is possible because values are positioned in the Urkel
Tree according to their key, therefore a proof of non-existence is exactly the
same as a proof of existence with the exception of the final leaf. Modifying a
proof of course changes the root hash that proof anchors to. We can use this
principle in reverse, to prove what the new tree root hash is AFTER the desired
operation.</p><pre tabindex=0><code>    (1) Tree:                   (2) Non-existence proof for `111`:

       Root A
       /    \                       /    \
      0      1                     0              hash(0)
     / \    / \                          / \
   00  010 10 110                       10 110    hash(10), leaf(110)
   /\      /\
000 001 100  101                                  Valid if == Root A


                                (3) Insertion data for `111`:
                                    Root B
                                    /    \
                                   0               hash(0)
                                         / \
                                        10         hash(10)
                                            /\
                                         110  111  hash(110), leaf(111)

                                                   New tree root = Root B

    (4) New Tree:      
                       
        Root B         
       /      \        
      0        1       
     / \     /   \     
   00  010 10     11   
   /\      /\     / \  
000 001 100 101 110 111
</code></pre><p>This diagram illustrates an example Urkel tree with 3 bits. 1- and 2-
digit numbers in the diagram indicate internal nodes of tree.</p><p>(1) There are 6 leaves in the tree (<code>000</code>, <code>001</code>, <code>010</code>, <code>100</code>, <code>101</code>, and <code>110</code>).</p><p>(2) To prove that the key <code>111</code> does NOT exist in this tree, we need to provide two hashes and the
full leaf node at the collision point. The verifier combines that data together
to compute a root hash. If that root hash matches the expected root hash (i.e.
the root hash committed to a specific block header) then the proof is valid.</p><p>(3) We can convert this proof of non-existence into a proof of existence by
creating a new internal node (<code>11</code>), and hashing the final leaf node (<code>110</code>).
This makes the proof one level deeper, where <code>110</code> and <code>111</code> are now positioned.</p><p>(4) The mutated proof will result in an entirely different root hash, which
is exactly the same hash produced by actually inserting the new node into the
complete tree!</p><h2 id=specification>Specification</h2><p>The specification currently uses 20 byte hashes in order to fit deeper Urkel
proofs into the <code>UPDATE</code> data. 32 byte hashes would be preferable, but would
result in significantly lower capacity for dSLDs (an Escher tree using 32 byte
hashes will only have capacity for about 100 dSLDs in most proofs under 374
bytes).</p><p>We currently choose <code>ed25519</code> for dSLD ownership because of smaller key
size (32 bytes) and compatibility with other blockchain systems like Sia.</p><p><code>P-256</code> is also a good option because ECDSA allows for public key recovery,
which could save us 32 bytes in the update proofs, but <code>P-256</code> uses bigger
public keys (64 bytes)</p><p>Since these dSLD keys will eventually be used to sign DNS zone files, it makes
sense to choose a standard DNSSEC algorithm (this is why <code>secp256k1</code>, the HNS
native signing algorithm, was not selected).</p><h3 id=definitions>Definitions</h3><p><code>ESCHER_VERSION</code>: <code>0x80</code></p><p>A HNS TLD is said to be &ldquo;in Escher mode&rdquo; if the first byte of its data resource
is equal to <code>ESCHER_VERSION</code>.</p><p>Escher Tree:</p><ul><li>hash function: <code>Blake2b160</code></li><li>bits: <code>160</code></li></ul><p>dSLD algorithm: <code>ed25519</code></p><p><code>namehash</code>: The blake2b160 digest of the DNS wire-formatted domain name.</p><blockquote><p>Example:</p><p>Domain name: <code>campaign.chaos.</code></p><p>DNS name serialization: <code>0863616d706169676e056368616f7300</code></p><p>Escher namehash: <code>3199fb4d363f59a8836769be02d201e3bfbc0366</code></p></blockquote><p><code>signature</code>: The signature over the a message committing to the NEW public key,
the current Escher root hash, and the magic string <code>"EscherMessage"</code> encoded
in ASCII.</p><blockquote><p>Example:</p><p>Current public key: <code>f5e5c982f8084efec7964e68b6f61cf529f656fb6d2e343ff42cc8ea9520ed5c</code></p><p>Magic string: <code>4573636865724d657373616765</code></p><p>Current tree root: <code>6c3bc60ab45fe53ec7c6e9948fa87e558d2cbf23</code></p><p>New public key: <code>0bf7920cbd5b4697704952ac5aa7d0d4de92d643368c544da4c5d2706204d4ed</code></p><p>Complete signed message:</p><pre tabindex=0><code>4573636865724d6573736167656c3bc60ab45fe53ec7c6e9948fa87e558d2cbf23
0bf7920cbd5b4697704952ac5aa7d0d4de92d643368c544da4c5d2706204d4ed
</code></pre><p>Signature:</p><pre tabindex=0><code>bf1a62fd4f4c234b6e6cdf4d52b7397c1c2db2e9848bdab996003bfcc7cfd29a
c6f911e71c3b0ef329df20cf42d48312940fcc7ef3da5882e890737d1690b901
</code></pre></blockquote><h3 id=message-format>Message format</h3><p>This is the data that must fit in the 512 byte <code>UPDATE</code> covenant data item:</p><table><thead><tr><th>size</th><th>data</th></tr></thead><tbody><tr><td>1</td><td><code>ESCHER_VERSION</code></td></tr><tr><td>20</td><td>proposed new tree root</td></tr><tr><td>1</td><td>method (REGISTER: <code>0x00</code>, UPDATE: <code>0x01</code>)</td></tr><tr><td>20</td><td><code>namehash</code></td></tr><tr><td>&mldr;</td><td>parameters (see below)</td></tr></tbody></table><h4 id=register-0x00-parameters>REGISTER: 0x00 parameters</h4><table><thead><tr><th>size</th><th>data</th></tr></thead><tbody><tr><td>32</td><td>NEW public key</td></tr><tr><td>4-438</td><td>Urkel proof-of-nonexistence of <code>namehash</code></td></tr></tbody></table><h4 id=update-0x01-parameters>UPDATE: 0x01 parameters</h4><table><thead><tr><th>size</th><th>data</th></tr></thead><tbody><tr><td>32</td><td>NEW public key</td></tr><tr><td>64</td><td><code>signature</code></td></tr><tr><td>4-374</td><td>Urkel proof of OLD public key of <code>namehash</code></td></tr></tbody></table><h2 id=new-consensus-rules>New consensus rules</h2><p>The following rules apply to <code>verifyCovenants()</code> which is called by both
mempool and chain for every output of every transaction as part of full
validation. This function is already responsible for checking name ownership,
name auction state and so forth. The current <code>nameState</code> for a name is always
retrieved from the current Urkel tree, meaning the validator already has the
current nameState <code>data</code> in memory. This data is set by the <em>previous</em> <code>UPDATE</code>
or <code>REGISTER</code> and is referred to as <code>current</code>.</p><p>The data being checked (in the <code>UPDATE</code> covenant of the transaction being
checked) is referred to as <code>proposed</code>.</p><p>If any of these rules are violated, verification fails immediately and the entire
transaction being considered MUST be rejected from mempool or block:</p><ol><li><p>If <code>current[0] !== ESCHER_VERSION</code> the name is not in Escher mode</p><ol><li>If <code>proposed[0] === ESCHER_VERSION</code> the name is entering Escher mode
and the version byte MUST be followed by 20 bytes of <code>0x00</code>. This is the
root hash of the empty Escher tree.</li><li>If the name is not in or entering Escher mode, no additional rules apply.</li></ol></li><li><p>If the name is in Escher mode it MUST remain in Escher mode, i.e.
<code>proposed[0] === ESCHER_VERSION</code> is required. (There is no escaping Escher mode!)</p></li><li><p>Bytes 1-20 of <code>current</code> are read and referred to as <code>currentRoot</code>. This is
the root hash of the current Escher tree.</p></li><li><p>After the version byte, <code>proposed</code> MUST have at least 42 bytes of data remaining:</p><ol><li><code>proposedRoot</code> (20 bytes)</li><li><code>opcode</code> (1 byte)</li><li><code>namehash</code> (20 bytes)</li><li>parameters (at least 1 byte)</li></ol></li><li><p>If <code>opcode === 0x00</code> the operation is a <code>REGISTER</code> and parameter validation follows:</p><ol><li>read <code>newKey</code> (32 bytes)</li><li>read <code>proof</code> (all remaining bytes)</li><li><code>proof</code> MUST be a valid Urkel non-existence proof for <code>namehash</code> in the tree
committed by <code>currentRoot</code>.</li><li><code>proof</code> is mutated into an existence proof for the <code>key:value</code> pair
<code>namehash:newKey</code> and a new root hash is computed.</li><li>This new root hash MUST be exactly equal to <code>proposedRoot</code>.</li></ol></li><li><p>If <code>opcode === 0x01</code> the operation is an <code>UPDATE</code> and parameter validation follows:</p><ol><li>read <code>newKey</code> (32 bytes)</li><li>read <code>signature</code> (64 bytes)</li><li>read <code>proof</code> (all remaining bytes)</li><li><code>proof</code> MUST be a valid Urkel proof for key <code>namehash</code> in the tree committed
by <code>currentRoot</code>. The value of <code>proof</code> is <code>oldKey</code>.</li><li><code>proof</code> is mutated to change the value from <code>oldKey</code> to <code>newKey</code> and a new
root hash is computed.</li><li>This new root hash MUST be exactly equal to <code>proposedRoot</code>.</li><li>Finally, <code>signature</code> MUST be a valid <code>ed25519</code> signature over the message defined
above (committing to <code>newKey</code>).</li></ol></li></ol><h2 id=name-servers>Name servers</h2><p>Escher is an ownership protocol and is designed only to assign SLDs to
public keys (literally <code>namehash:pubkey</code>). Escher does NOT solve the problem
of data availability. Zone files for dSLDs SHOULD be made available on a single
network extension like a DHT or Kademlia protocol maintained by providers. These
providers must also serve current Escher proofs for dSLDs. Providers will likely
be incentivized by dSLD owners or TLD owners in order to resolve dSLDs.</p><p>A precise protocol for dSLD resolution will be specified in a future HIP. What
Escher does is simply authenticate that data. Because zone files are signed with
expiration times, the data can be hosted anywhere by anyone. Escher can be used
to ensure that only valid data (signed by the dSLD owner) is served.</p><h2 id=implementation>Implementation</h2><p>Extra methods are required in the Urkel library for proof mutation:</p><p><a href=https://github.com/handshake-org/urkel/pull/24>https://github.com/handshake-org/urkel/pull/24</a></p><p>Soft fork and validation rules:</p><p><a href=https://github.com/handshake-org/hsd/pull/761>https://github.com/handshake-org/hsd/pull/761</a></p><hr><div class=info><strong>HIP:</strong><div>0016</div><strong>Status:</strong><div><a href=/status/draft>Draft</a></div><strong>Type:</strong><div><a href=/category/standards>Standards</a></div><strong>Created:</strong><div>Sat, 23 Jul 2022</div><strong>Last commit:</strong><div>Wed, 14 Sep 2022</div><strong>Author:</strong><div>Matthew Zipkin &lt;@pinheadmz></div></div><hr><a href=https://github.com/handshake-org/HIPs/blob/master/HIP-0016.md>Edit on GitHub</a></div></section><aside><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#abstract>Abstract</a></li><li><a href=#motivation>Motivation</a></li><li><a href=#limitations>Limitations</a></li><li><a href=#mechanism>Mechanism</a></li><li><a href=#specification>Specification</a><ul><li><a href=#definitions>Definitions</a></li><li><a href=#message-format>Message format</a></li></ul></li><li><a href=#new-consensus-rules>New consensus rules</a></li><li><a href=#name-servers>Name servers</a></li><li><a href=#implementation>Implementation</a></li></ul></nav></aside></article></main><footer id=footer>©&nbsp;2021 Handshake Community<a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>(Creative
Commons Attribution-ShareAlike 4.0 International License)</a></footer></body></html>